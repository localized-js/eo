import localized from '@localized/core';
const { array } = localized;

export const interligi = array.concat() as <A>(tabelo: A[], ...elementoj: ConcatArray<A>[]) => A[];
export const moviMemoron = array.copyWithin() as <A>(tabelo: A[], celo: number, komenco?: number, fino?: number) => A[];
export const eniroj = array.entries() as <A>(tabelo: A[]) => IterableIterator<[number, A]>;
export const ĉiu = array.every() as <A>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => elemento is A) => boolean;
export const cxiu = ĉiu;
export const plenigi = array.fill() as <A>(tabelo: A[], valoro: A, komenco?: number, fino?: number) => A[];
export const filtri = array.filter() as <A>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => elemento is A) => A[];
export const trovi = array.find() as <A>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => elemento is A) => A;
export const troviIndekso = array.findIndex() as <A>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => elemento is A) => number;
export const platigi = array.flat() as <A>(tabelo: A[], profundeco: number) => FlatArray<A, 0 | 2 | 1 | -1 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20>[];
export const plataMapi = array.flatMap() as <A, B>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => B) => B[];
export const porĈiu = array.forEach() as <A>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => void, thisArgumento?: any) => void;
export const porCxiu = porĈiu;
export const inkluzivas = array.includes() as <A>(tabelo: A[], serĉaElemento: A, deirpunkto?: number) => boolean;
export const indeksoDe = array.indexOf() as <A>(tabelo: A[], serĉaElemento: A, deirpunkto?: number) => number;
export const unuigi = array.join() as <A>(tabelo: A[], apartigilo?: string) => string;
export const klavoj = array.keys() as <A>(tabelo: A[]) => IterableIterator<number>;
export const lastaIndeksoDe = array.lastIndexOf() as <A>(tabelo: A[], serĉaElemento: A, deirpunkto?: number) => number;
export const mapi = array.map() as <A, B>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => B) => B[];
export const kraketi = array.pop() as <A>(tabelo: A[]) => A;
export const puŝi = array.push() as <A>(tabelo: A[], ...elementoj: A[]) => number;
export const pusxi = puŝi;
export const redukti = array.reduce() as (<A, B>(tabelo: A[], funkco: (antaŭaElemento: B, kurantaElemento: A, kurantaIndekso: number, tabelo: A[]) => B, akumulilo: B) => B) & (<A>(tabelo: A[], funkco: (antaŭaElemento: A, kurantaElemento: A, kurantaIndekso: number, tabelo: A[]) => A) => A);
export const dekstraRedukti = array.reduceRight() as (<A, B>(tabelo: A[], funkco: (antaŭaElemento: B, kurantaElemento: A, kurantaIndekso: number, tabelo: A[]) => B, akumulilo: B) => B) & (<A>(tabelo: A[], funkco: (antaŭaElemento: A, kurantaElemento: A, kurantaIndekso: number, tabelo: A[]) => A) => A);
export const inversigi = array.reverse() as <A>(tabelo: A[]) => A[];
export const movi = array.shift() as <A>(tabelo: A[]) => A;
export const tranĉi = array.slice() as <A>(tabelo: A[], komenco?: number, fino?: number) => A[];
export const kelke = array.some() as <A>(tabelo: A[], funkco: (elemento: A, indekso: number, tabelo: A[]) => unknown) => boolean;
export const klasi = array.sort() as <A>(tabelo: A[], komparaFunkco?: (a: A, b: A) => number) => A[];
export const splisi = array.splice() as <A>(tabelo: A[], komenco: number, kvantoForigi?: number, ...elementoj: A[]) => A[];
export const malmovi = array.unshift() as <A>(tabelo: A[], ...elementoj: A[]) => number;
export const valoroj = array.values() as <A>(tabelo: A[]) => IterableIterator<A>;
export const signovicigi = array.toString() as <A>(tabelo: A[]) => string;
export const lokaSignovicigi = array.toString() as <A>(tabelo: A[]) => string;
export const longeco = array.length() as <A>(tabelo: A[]) => number;
export const de = array.from() as (<A, U>(tabelSimila: ArrayLike<A>, funkco: (elemento: A, indekso: number) => U) => U[] & (<A>(tabelSimila: ArrayLike<A>) => A[]));
export const da = array.of() as <A>(...elementoj: A[]) => A[];
export const estasTabelo = array.isArray() as (parametro: any) => parametro is any[];